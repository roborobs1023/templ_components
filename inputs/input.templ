package inputs

import (
	"fmt"
	"github.com/roborobs1023/templ_components/internal/utils"
	"strings"
	"time"
)

type InputOpts struct {
	ID    string
	Name  string
	Type  InputType
	Value string
	Label string

	Required   bool
	Disabled   bool
	Readonly   bool
	Autofocus  bool
	Spellcheck bool

	Autocomplete string
	Placeholder  string

	Tabindex int
	Form     string
	Class    string
	Attrs    templ.Attributes
	addressProps
	dateProps
	timeProps
	emailProps
	numberProps
	optionProps
	PasswordReq
	phoneProps
	selectProps
	textProps
	textareaProps
	fileProps
	rangeProps
}

type InputType string

func (t InputType) String() string {
	return string(t)
}

const (
	ADDRESS     InputType = "address"
	CHECKBOX    InputType = "checkbox"
	COLOR       InputType = "color"
	DATE        InputType = "date"
	DATETIME    InputType = "datetime-local"
	EMAIL       InputType = "email"
	FILE        InputType = "file"
	HIDDEN      InputType = "hidden" // Used for inputs that need not be visible but value needs to be submitted with form.
	MONTH       InputType = "month"
	NEWPASSWORD InputType = "new-password"
	NUMBER      InputType = "number"
	PASSWORD    InputType = "password"
	PHONE       InputType = "tel"
	RADIO       InputType = "radio"
	RANGE       InputType = "range"
	SEARCH      InputType = "search"
	SELECT      InputType = "select"
	TEXT        InputType = "text"
	TIME        InputType = "time"
	URL         InputType = "url"
	WEEK        InputType = "week"
)

type InputOptsFunc func(p *InputOpts)

func New(label, name string, inputType string, opts ...InputOptsFunc) {

	p := InputOpts{
		ID:    utils.NewID(name),
		Name:  name,
		Label: label,
		Type:  InputType(inputType),
	}

	for _, fn := range opts {
		fn(&p)
	}

	// switch p.Type {
	// case ADDRESS:
	// case CHCECKBOX:
	// case COLOR:
	// case DATE:
	// case DATETIME:
	// case EMAIL:
	// case FILE:
	// case HIDDEN:
	// case MONTH:
	// case NEWPASSWORD:
	// case NUMBER:
	// case PASSWORD:
	// case PHONE:
	// case RADIO:
	// case RANGE:
	// case SEARCH:
	// case SELECT:
	// case TIME:
	// case URL:
	// case WEEK:
	// default:

	// }

}

func Required(p *InputOpts) {
	p.Required = true
}

func Readonly(p *InputOpts) {
	p.Readonly = true
}
func Disabled(p *InputOpts) {
	p.Disabled = true
}

func Autofocus(p *InputOpts) {
	p.Autofocus = true
}

func Spellcheck(p *InputOpts) {
	p.Spellcheck = true
}

func Autocomplete(value string) InputOptsFunc {
	return func(p *InputOpts) {
		p.Autocomplete = value
	}
}

func Placeholder(value string) InputOptsFunc {
	return func(p *InputOpts) {
		p.Placeholder = value
	}
}

func DefaultValue(value any) InputOptsFunc {
	return func(p *InputOpts) {
		p.Value = fmt.Sprintf("%v", value)
	}
}

func Form(value string) InputOptsFunc {
	return func(p *InputOpts) {
		p.Form = value
	}
}

func Class(value string) InputOptsFunc {
	return func(p *InputOpts) {
		p.Class = value
	}
}

func Tabindex(value int) InputOptsFunc {
	return func(p *InputOpts) {
		p.Tabindex = value
	}
}

// Text Input Props
func Pattern(value string) InputOptsFunc {
	return func(p *InputOpts) {
		p.Pattern = value
	}
}

func MinLength(value int) InputOptsFunc {
	return func(p *InputOpts) {
		p.MinLength = value
	}
}

func MaxLength(value int) InputOptsFunc {
	return func(p *InputOpts) {
		p.MaxLength = value
	}
}

// Number Input Props
func Min(value float64) InputOptsFunc {
	return func(p *InputOpts) {
		p.Min = value
	}
}

func Max(value float64) InputOptsFunc {
	return func(p *InputOpts) {
		p.Max = value
	}
}

func Step(value float64) InputOptsFunc {
	return func(p *InputOpts) {
		p.Step = value
	}
}

// Email Input Props
func AcceptedDomains(domains []string) InputOptsFunc {
	return func(p *InputOpts) {
		p.AcceptedDomains = domains
	}
}

// Select/Checkbox/Radio Input Props
func Options(options map[string]string) InputOptsFunc {

	return func(p *InputOpts) {

		Options := []option{}

		for key, value := range options {

			Options = append(Options, NewOption(key, value))
		}

		p.Options = Options
	}
}

// Date Input Props
func MinDate(value time.Time) InputOptsFunc {
	return func(p *InputOpts) {
		p.MinDate = value
	}
}

func MaxDate(value time.Time) InputOptsFunc {
	return func(p *InputOpts) {
		p.MaxDate = value
	}
}

// Time Input Props
func MinTime(value time.Time) InputOptsFunc {
	return func(p *InputOpts) {
		p.MinTime = value
	}
}

func MaxTime(value time.Time) InputOptsFunc {
	return func(p *InputOpts) {
		p.MaxTime = value
	}
}

// Textarea Input Props
func Rows(value int) InputOptsFunc {
	return func(p *InputOpts) {
		p.Rows = value
	}
}

func Columns(value int) InputOptsFunc {
	return func(p *InputOpts) {
		p.Cols = value
	}
}

// Select Props
func ShowOther(p *InputOpts) {
	p.ShowOther = true
}

func ShowClear(p *InputOpts) {
	p.ShowClear = true
}

func Searchable(p *InputOpts) {
	p.Searchable = true
}

// New-Password Input Props
func SetPasswordReqs(req PasswordReq) InputOptsFunc {
	return func(p *InputOpts) {
		p.PasswordReq = req
	}
}

func AddressProps(City, State, CountryCode string) InputOptsFunc {
	return func(p *InputOpts) {
		p.addressProps = addressProps{
			DefCountry: CountryCode,
			DefCity:    City,
			DefState:   State,
		}
	}
}

// File Input Props
func CaptureEnv(p *InputOpts) {
	p.Capture = "environment"
}

func CaptureUser(p *InputOpts) {
	p.Capture = "user"
}

func Accept(fileTypes []string) InputOptsFunc {
	return func(p *InputOpts) {
		p.Accept = strings.Join(fileTypes, ", ")
	}
}

func UseDataList(id string, options map[string]any) InputOptsFunc {
	return func(p *InputOpts) {
		p.ListID = id
		p.CMP = dataList(id, options)
	}
}

func SetAttributes(attrs templ.Attributes) InputOptsFunc {
	return func(p *InputOpts) {
		p.Attrs = attrs
	}
}

templ dataList(id string, options map[string]any) {
	<datalist id={ id }>
		for lbl, value := range options {
			<option value={ fmt.Sprintf("%v", value) } label={ lbl }></option>
		}
	</datalist>
}
